Các nền tảng defi khác



# Oasis Network
Là 1 blockchain layer 1. Token ROSE. Dùng PoS, tổng cung giới hạn 10 tỷ.
Đặc điểm: nó là 1 blockchain bình thường cho phép xây dựng các ứng dụng phi tập trung chỉ là riêng tư hơn, nhanh hơn, khả năng mở rộng cao hơn (so với Ethereum truyền thống), bảo mật tốt. Để làm được v, nó có nhiều điểm khác biệt về cơ chế bảo mật cũng như tính năng khác mà các blockchain khác không có.

Người dùng có thể stake data để nhận thưởng, gọi là tokenized data, các blockchain khác chỉ được stake token. Điều này dễ hiểu vì data cũng có giá trị như tiền. Data Provider stake data vào Oasis Network và nhận thưởng, Data Consumer trả phí và nhận về data. 

Oasis có 2 thành phần kiến trúc chính tách biệt là:
Consensus Layer: PoS thực hiện bảo mật, nó dùng SDK của Cosmos.
Paratime Layer: là lớp phi tập trung cho phép bất cứ ai cũng có thể xây dựng được paratime của riêng họ. 
=> Cái lớp paratime này cho phép khả năng mở rộng cao và hỗ trợ các nhu cầu tính toán chuyên biệt vì: nó lưu trữ nhiều thời gian chạy song song. Mỗi paratime đại diện cho 1 môi trường tính toán sao chép và chia sẻ được trạng thái cho nhau. Bất cứ ai cũng có thể tạo ra paratime cho 1 mục đích chuyên biệt như paratime tính toán bí mật, paratime được cấp phép, EVM paratime,...; Paratime là nơi xử lý phần tính toán được tách biệt khỏi phần đồng thuận nên nhanh hơn, mà phần tính toán người dùng tạo ra tùy ý theo ý họ phục vụ cho riêng mục đích cụ thể nên khả năng mở rộng cao

Các paratimme riêng tư người dùng tạo ra có thể viết các ứng dụng trên đó, tạo ra các smart contract riêng tư. Nó mở ra các TH sử dụng mới như private lending, private AMM,.. với khả năng mở rộng cao vì người dùng có thể tùy ý chỉnh sửa paratime phù hợp với nhu cầu ứng dụng của mình như lớn hay nhỏ, mở hay đóng, chỉ mở cửa vào 1 khung giờ cụ thể chẳng hạn.
=> Thêm nhiều tính năng thú vị vào blockchain trong khi chỉ cần duy trì cái cốt lõi là sổ cái đồng thuận. 
Các paratime chạy song song nhau
Phí chắc chắn thấp hơn ethereum và bitcoin. 

Token ROSE: dùng làm phí giao dịch, staking hay delegator tại lớp đồng thuận; dùng trả thưởng cho các staker và delegator để bảo mật cho mạng lưới

(Tránh nhầm với dự án rose.fi là 1 smart contract trên Aura blockchain, k liên quan gì đến oasis, chỉ là trùng tên token ROSE mà thôi)

Oasis tạo ra nền kinh tế dữ liệu có trách nhiệm đầu tiên.
Việc tách biệt đồng thuận và thực thi thành 2 lớp cho phép nhiều paratime xử lý các giao dịch song song làm cho khối lượng công việc phức tạp được xử lý trên 1 paratime không làm chậm các giao dịch nhanh hơn được xử lý trên 1 paratime khác
Tính năng phát hiện giả mạo tinh vi trong oasis hiệu quả hơn sharding và parachain dù chưa hiểu vì sao nó nhanh và an toàn hơn

Mạng oasis thiết kế ra paratime bảo mật đầu tiên với sự hỗ trợ của các smart contract bảo mật. Paratime đó sử dụng công nghệ tính toán là TEE(Trusted Execution Environment - môi trường thực thi đáng tin cậy)
TEE hoạt động như 1 hộp đen giả định, dữ liệu mã hóa đi vào hộp đen cùng với smart contract và được giải mã, xử lý bởi smart contract và được mã hóa trở lại trước khi gửi ra ngoài TEE. Từ bên ngoài thì dữ liệu luôn trong trạng thái mã hóa nên được bảo mật và kbh rò rỉ. Có thể dùng nó với các thông tin cần bảo mật như dữ liệu sức khỏe cá nhân nhạy cảm, số an sinh xh, sao kê ngân hàng.
Encrypted data + smart contract -> Secure enclave -> Encrypted Result

VD: Nền tảng cryptosafe được phát triển bởi Oasis Labs và Binance cho phép các sàn giao dịch chia sẻ dữ liệu 1 cách bí mật giữa các sàn giao dịch về các mối đe dọa từ các cuộc tấn công
VD: 1 nhà cung cấp dịch vụ chăm sóc sức khỏe muốn chia sẻ dữ liệu với bên thứ 3 trong khi vẫn giữ quyền kiểm soát dữ liệu và bảo vệ tính bí mật của dữ liệu bệnh nhân. Sử dụng API do Oasis Labs xd, công ty chăm sóc sức khỏe có thể quản lý, theo dõi, kiểm soát tất cả việc sử dụng dữ liệu ngay cả khi được chia sẻ với bên thứ 3, chứ kp chia sẻ ra là mất quyền kiểm soát data
Vd: Công ty muốn cho người dùng kiểm soát dữ liệu di truyền của họ, nhờ oasis, khách hàng có thể giữ quyền sở hữu dữ liệu bộ gen của họ và công ty có thể phân tích dữ liệu mà k cần xem thông tin thô của khách hàng
=> Khá mơ hồ



# Ve(3,3)
Phát triển bởi Andre Cronje(bố già DeFi, Yearn, Fantom blockchain) và Daniele(người đứng sau nhiều dự án DeFi 2.0, Wonderland) là KOL
KOL: Key opinion leader là người dẫn dắt dư luận

ve(3,3)(token SOLID): thì (3,3) chỉ win-win, mọi người tham gia đều thắng. Còn ve(vote escrow) là ký hiệu token được khóa vào pool. 
VD người dùng lock CRV vào pool để nhận về veCRV, tức nó là phần thưởng tương tự nhưng kèm quyền biểu quyết. (3,3) tượng trưng mô hình OlympusDAO, người dùng stake càng nhiều OHM càng tốt.
=> ve(3,3) khuyến khích người dùng lock token vào pool đồng thời tạo ra mô hình giá trị win-win cho người tham gia

1 dự án ra đời muốn tạo doanh thu thì cần có người dùng trả phí. Nhưng 1 dự án mới ra thì làm gì có ai. Bình thường họ sẽ làm kiểu trả token để khuyến khích người dùng vào. Nhưng token cứ in mãi sẽ giá giảm và lạm phát.
Cơ chế emission token: tùy vào tỉ lệ cung lưu thông, VD chưa có token nào khóa thì emission rate là 2 triệu. Nếu có 50% token khóa thì emisstion là 1 triệu và 100% thì giảm về 0.
veCRV thì yêu cầu người dùng khóa token CRV vào càng lâu thì nhận càng nhiều veCRV. Khi đó họ dùng để quản trị, nhận fee giao dịch, boosting phần thưởng. Nhược điểm lại là vốn bị khóa cứng trong giao thức và k thể lưu thông được.
Còn (3,3) là mô hình lý thuyết trò chơi của OlympusDAO. Nó cũng chỉ là khuyến khích người dùng stake càng nhiều OHM càng tốt. Lý do là vì giá trị tối thiểu của giao thức này là giá trị kho bạc mà nó sở hữu. Giá trị token càng cao thì lợi nhuận càng nhiều. Nhược điểm là giá trị OHM mint ra càng nhiều giá càng giảm.

=> ve(3,3) là sự kết hợp 2 cái đó. Mọi người khóa tài sản vào và ăn phí. Emission rate diễn ra hàng tuần và toàn bộ token phân phối ra thị trường đều trao cho những ai khóa token. Điều này tạo động lực để người dùng khóa token vì khóa nó 1 tuần không unstake là nhận thêm khoảng 5% lượng bỏ vào r.
Câu hỏi đặt ra là khóa để làm gì? nó sẽ hình thành dưới dạng NFT và được phép bán trên thị trường thứ cấp. Các NFT đó là token bị khóa hay gọi là bán quyền biểu quyết, ta có thể bán trên OpenSea chẳng hạn. Toàn bộ phí gửi hết cho người lock ve(3,3). Việc này khắc phục nhược điểm của CRV khi mà người dùng lock là bị khóa cứng luôn.
Nếu có ai muốn lạm dụng stake token để chiếm quyền kiểm soát thì lượng token trả thưởng cho họ sẽ thấp lại, phòng ngừa rủi ro.

ve(3,3) có 100% lượng token lưu hành thuộc về cộng đồng. K có nhà đầu tư hay private sale này nọ. Người dùng k thể mua SOLID theo hình thức bình thường mà nó phân phối cho 20 giao thức hàng đầu trên Fantom blockchain theo TVL. Nhờ v lượng ví blockchain fantom tăng vọt

ve(3,3) khuyến khích thu phí giao dịch hơn là cung cấp thanh khoản. Dự án k cần tạo pool thanh khoản cho tài sản. Những người khóa tài sản vào giao thức sẽ nhận được 100% phí thu được từ các pool mà họ vote cho, ở chiều ngược lại, các pool có thể đặt mức phí cao hơn. 



# API3
API3(token API3) là nền tảng oracle cho phép các DApp truy cập vào dữ liệu và dịch vụ thế giới thực thông qua API, hay gọi là dAPI.
API3 quản lý bởi tổ chức tự trị phi tập trung DAO, gọi là API3 DAO nên open source và minh bạch

Thông thường API giúp ứng dụng và thư viện kết nối với nhau nhằm trao đổi dữ liệu. Nhưng để đưa các dữ liệu này vào blockchain là không thể vì API bình thường k hoạt động với smart contract. Điều này khiến cho blockchain là 1 mạng lưới khác nhưng cô lập với mạng lưới internet bình thường ta hay dùng v. API3 giải quyết vấn đề đó.

API3 là token ethereum ERC20 giúp API truyền thống kết nối với hệ sinh thái blockchain. API3 dùng để quản trị API3 DAO, vote các upgrade.

-> Cơ chế: Nó xây dựng bằng cách kết hợp nhiều oracle node do nhà cung cấp vận hành thành nguồn cấp dữ liệu tổng hợp, k cần bên thứ 3
Thông thường ở các loại oracle trước đó có cơ chế kiểu nhét thông tin vào oracle và lấy thông qua các node của bên thứ 3 trung gian. Bởi vì các nhà cung cấp API gặp nhiều rào cản khi tự vận hành 1 oracle node riêng. Bởi vì các công ty quản lý dữ liệu không quen thuộc với blockchain, họ không có kiến thức về mảng này và cũng chẳng cần phải làm vậy. Oracle node vận hành tốn tài nguyên và chi phí, nhân lực. Vận hành oracle node bình thường sẽ phải thanh toán phí gas cho mạng lưới và giao dịch tiền điện tử rắc rối. 
=> API3 loại bỏ bên trung gian bằng cách sử dụng luôn Oracle Node của bên thứ nhất(là nhà cung cấp dữ liệu gốc). Họ cho ra phần mền Airnode để nhà cung cấp API chuyển API của họ thành dAPI và mn vào thẳng nguồn trực tiếp. Như vậy sẽ phi tập trung hơn bản cũ. Lưu ý điều này khác với kiểu của The Graph nhé. Ở đây ta vẫn dùng Oracle nhưng bỏ node đi thôi. Cơ chế của Oracle là người dùng tổng hợp thông tin từ nhiều node để cho ra kết quả cuối đúng nhất khác với Graph là chọn 1 subgraph để lấy thông tin vì đã tin tưởng subgraph là đã phi tập trung sẵn r.
Với phần mềm Airnode thì các nhà cung API có thể dễ dàng triển khai, ít bảo trì và không cần nắm rõ kiển thức về blockchain. Nó cho toàn quyền nhà cung cấp API có thể chạy oracle miễn phí nếu thích và chỉ trả phí nếu họ bắt đầu tạo ra doanh thu. Airnode chính là mấu chốt cũng chỉ là tool giúp tạo node dễ hơn, nó là 1 node oracle k có máy chủ thiết kế dành riêng cho API provider. Các nhà cung node cx kp trả phí mà người dùng trả hết.

Điểm nổi bật:
Chính là việc cung cấp lấy dữ liệu và dịch vụ trực tiếp từ nhà cung cấp API. Tránh được tình trạng nhiều node trung gian liên kết với nhau cung ra kết quả sai.
Bỏ qua node trung gian giúp tiết kiệm chi phí vì bình thường trong các dự án họ thường xử lý vấn đề khi có 1 khâu nào đó là tập trung bằng cách phạt rất nặng so với tiền thưởng, kiểu stake token vào chẳng hạn. Nhưng nhờ kiểu này thì đã xử lý khâu trung gian có nguy cơ tập trung rồi. Tuy API3 xử lý vấn đề đó thì người dùng k cần stake token vào để trở thành node nhưng cơ chế staking khác trong API3 có mục đích bảo hiểm cho người dùng. Nếu gặp rủi ro họ sẽ đền bù bằng token API3, ngược lại trong TH bình thường thuận lợi, người dùng stake API3 sẽ được profit.
=> Tức là tổng hợp từ nhiều dAPI thành 1 API hoàn chỉnh + người cung stake để đền bù, nếu hoạt động tốt sẽ được profit từ người dùng trả phí.

-> So sánh 4 oracle nổi tiếng:
ChainLink: Data Provider -> Oracle Nodes -> chuỗi tổng hợp -> data consumers
Band Protocol: Data Provider -> BandChain: Nodes/Validators (có delegator) -> chuỗi tổng hợp -> data consumers
Pyth: Data Provider -> chuỗi tổng hợp (có curator và delegator trong Solana) -> data consumers
API3: Data Provider -> chuỗi tổng hợp -> data consumers

API3 và Pyth ra đời sau và cho phép data provider truyền thẳng vào chuỗi tổng hợp mà không cần qua oracle nodes trung gian như 2 dự án trước đó.
Data Provider có thể cung dữ liệu free or fee. 1 ví dụ về nhà cung cấp dữ liệu free là CoinGecko.

Các node của Band Protocol vận hành 1 chuỗi khối riêng biệt BandChain. Nó có tập hợp các Validataor riêng cho mình để đồng thuận nx. Còn Chainlink thì tương tự nhưng các node không vận hành 1 chuỗi khối riêng mà các node sẽ liên kết với nhau tạo thành mạng P2P off-chain DONs. Nó có nhiều nhóm chạy node riêng biệt với quy mô khác nhau, cung cấp dữ liệu khác nhau cho các chuỗi khác nhau. Mõi chuỗi có 1 lượng node riêng như ETH, BSC, Matic, xDai.
Với chainlink có 2 hình thức tổng hợp dữ liệu là tổng hợp trên chuỗi FluxAggregator(FL) hoặc offchain(OCR). Với FL thì mỗi nút oracle cần trả tiền gas khi họ gửi giá của mình cho hợp đồng trên chuỗi. Với OCR thì chỉ 1 giá tổng hợp duy nhất được gửi lên chuỗi, về cơ bản thay vì có 21 node oracle đều phải trả tiền gas, chỉ cần 1 node theo phương pháp OCR. FL là hình thức phổ biến nhất là trên các chuỗi có chi phí gas thấp.
Doanh thu đến từ: người dùng trả phí để sử dụng dữ liệu; phần thưởng là mã thông báo
Chi phí đến từ: chi phí vận hành node; trả tiền gas theo từng chuỗi riêng vì cung data cho các chuỗi khác nhau mất phí nhiều hay ít khác nhau; trả tiền cho data provider. Khi khí gas trên chuỗi tăng quá lớn dẫn đến các node chainlink có thể lỗ do chi phí luôn cao hơn doanh thu

Pyth, API3 tiếp cận theo cách khác, loại bỏ các node oracle kiểu chainlink nằm trung gian ở giữa, yêu cầu data provider trực tiếp gửi data lên chuỗi tông hợp. Điều này giúp loại bỏ bên thứ 3, các data provider sẽ nhận nhiều tiền hơn do không phải san sẻ với các node. 
Pyth tổng hợp data trên chuỗi Solana. Chi phí cực rẻ và tốc độ cao nên lợi nhuận cao. Nhưng điều quan trọng là truyền thông từ Solana đến cac chuỗi khác, nơi có nhu cầu sử dụng dữ liệu. Pyth dùng Wormhole để làm điều này.
API3 cũng tương tự nhưng người dùng trả phí gas chứ kp provider. Nó k có tổng hợp ngoài chuỗi nên user cần thanh toán cho mỗi đơn phí gas của data provider. Phía cung giảm chi phí nhưng phía cầu bị tổn hại. 

--> Về bảo mật, do oracle được rất nhiều các mảnh ghép defi dùng tới và giá trị có thể lên tới chục tỷ đô la. Để giải quyết vấn đề bảo mật, thông thường ta cho họ đặt cược và phạt data không chính xác nhưng trong oracle thì nhu cầu phụ thuộc vào nó quá nhiều với số tiền khổng lồ và không ai có thể cược 1 khoản khổng lồ như v. Đây là vấn đề khó đối với oracle đòi hỏi sự tin tưởng vào các thợ đào và validator. Các hình thức vẫn cho đặt cọc để khuyến khích chứ k thể bảo mật hoàn toàn. Còn pyth và api3 tốt hơn khi mà nhà cung dữ liệu đặt chính uy tín của họ lên hàng đầu. Họ trực tiếp cung vào chuỗi tổng hợp, càng nhiều người dùng dùng của họ thì uy tín họ càng xây dựng lớn dần theo thời gian.
Ngược lại thì Chainlink cac node hoàn toàn ẩn danh thì lòng tin càng khó. Tuy nhiên các giải pháp khác như DECO và Town Crier của Chainlink ghi trong sách trắng v2 cho phép bên thứ 3 chứng minh họ không can thiệp vào dữ liệu từ nguồn.

Khi có thông tin sai lệch xảy ra, người dùng là những người bị thiệt hại. Với chainlink v2 thì nó sử dụng khoản phạt của node oracle đền bù cho user sử dụng. Pyth thì các data provider đặt cọc. API3 thì data provider k cần đặt cọc, họ chả bị phạt gì khi cung cấp thông tin sai. Họ không cần có token API3 khi provide data. Nếu cung sai thì uy tín giảm sẽ k có ai dùng nx. API3 phù hợp cho các nhà cung cấp API lớn và uy tín cao vì họ cung gần như k mất thêm chi phí. 

Chainlink họ phải mua LINK token để khóa data để họ cung. Bên cạnh việc lỗ hay lãi vì phí gas thì họ còn gặp vấn đề về giá token LINK giảm làm ảnh hưởng giá trị họ mua để đặt cọc. Chainlink để giải quyết tình trạng này đã phải cung 35% token khuyến khích người dùng để dành riêng cho việc này.



# Pavia
Decentraland(MANA) là 1 nền tảng thực tế ảo VR hỗ trợ bởi Ethereum. Viết bằng C# unity, Typescript,.. Người dùng có thể mua đất trên thế giới ảo này, tùy ý sáng tạo, xây dựng bất cứ thứ gì trên mảnh đất mua ở đó. Ta có thể trải nghiệm với tai nghe thực tế ảo hoặc browser(phải đáp ứng về cấu hình) để vào game. Nó là 1 loại dự án metaverse như Sandbox,..
Người dùng có thể đặt quảng cáo, trò chuyện, bán đất,.. Mỗi địa chỉ sẽ vào được metaverse là 1 người trong thế giới

Pavia tương tự Decentraland nhưng trên mạng Cardano dùng PoS. Mỗi thửa đất được đúc thành 1 Cardano NFT và được đánh số duy nhất dựa trên tọa độ. 
Ở thời điểm này, người dùng chưa làm gì được trên thửa đất của họ. 
Pavia(PAVIA) 25% token đã được airdrop cho chủ sở hữu
Pavia hợp tác với nền tảng hình đại diện trò chơi chéo có metaverse readyplayer.me để người dùng thiết kế hình đại diện tương thích bên ngoài hệ sinh thái Pavia trong hơn 700 ứng dụng và trò chơi

Các lô đất đầu tiên được phân bố ngẫu nhien tôn trọng phân phối công bằng

Bổ sung tính thanh khoản cho các sàn Cardano, bán thêm đất -> xây dựng giao diện Pavia.io -> cross chain, tăng khả năng tương tác -> sự kiện và các cổng thông tin



# Flow
Flow(FLOW) là blockchain layer 1 riêng, là blockchain có tốc độ tăng trưởng nhanh nhất. Số lượng NFT trên flow lớn nhất. Người sáng lập Flow cũng đồng sáng lập CryptoKitty là team Dapper Labs.

Ethereum hay Bitcoin yêu cầu các node làm công việc như nhau. Mỗi node yêu cầu vùng nhớ và vi xử lý cao sẽ rất chậm và tốn dù bảo mật tốt, phí cao. Dù có thêm 100 hay 1000 node thì tốc độ vẫn v thôi vì các node làm công việc như nhau.
Flow thì càng nhiều người dùng vào node xử lý thì tốc độ sẽ càng nhanh hơn. Họ có tham vọng tiếp cận hàng tỉ người dùng như 1 fly wheel càng nhiều người dùng càng nhanh, càng hút user lại càng hút node. Để làm điều đó họ đánh đổi sự phi tập trung ban đầu khi mà các nút hiện tại đa phần là của nhà phát triển nhưng sau này hệ thống mở rộng thì các nút đó sẽ phi tập trung hoàn toàn, chuyển giao cho người dùng và còn hơn các blockchian đi trước.

-> Flow sẽ tách ra nhiều 4 node khác nhau xử lý các khía cạnh kỹ thuật khác nhau:
Collection Node: gom các giao dịch lại để gửi tới các node khác xử lý. Chỉ cần bộ nhớ 200GB và vi xử lý thông thường. Collection node giúp tăng hiệu suất, network connectivity và data availability
Concensus Node: chịu trách nghiệm bảo mật phi tập trung, sắp xếp lại thứ tự các transaction, đóng gói vào block. Cấu hình tương tự collection node. Nó chạy BFT concensus.
Execution Node: xử lý logic các transaction. Cấu hình rất cao vì liên quan đến tốc độ và khả năng mở rộng nên kp ai cũng làm được. Tính toán đầu ra cuối cùng của block
Verification Node: Kiểm tra và duy trì giám sát các execution node, đảm bảo xử lý đúng. Điều kiện cấu hình chỉ như máy tính bth. 
=> Execution và collection node perform deterministic task khiến nó ít bị tấn công hơn nhưng phải có cấu hình phần cứng chuyên dụng. Các loại node được chuyên môn hóa với từng chức năng. Tăng khả năng mở rộng và giảm fee hàng nghìn lần so với ethereum

=> Node nào cũng phải stake Flow tùy vai trò phải stake nhiều hay ít. Phần thưởng khối mà các node nhận được cũng khác nhau và đổi theo nhu cầu của thị trường cần node nào nhiều hơn. 
Flow còn có nhóm node thứ 5 là Access Node giúp Collection Node tập hợp transaction nhưng k được kết hợp vào cơ chế của Flow blockchain vì chỉ có vai trò phụ là trợ giúp và cx k cần stake any Flow coin với loại node này

1000 transaction 1s, phí cực rẻ, dùng PoS HotStuff là preferred option cho các dự án NFT, smart contract trên Flow mặc định là có thể update được và author cũng có thể làm cho nó immutable nếu muốn. Account tự động được tạo ra bởi blockchain và cũng support multiple public key.

-> Multi-role architecture
Nhiều loại node cũng tăng tính phi tập trung, người bth cũng có thể trở thành 1 node. Sự phức tạp đã bị abstract đi vào trong protocol để developer đơn giản hơn khi khi tạo app nhanh hơn mà k cần quan tâm tới cơ sở hạ tầng bên dưới; Tăng trải nghiệm người dùng, tránh các giải pháp layer 2; Tăng bảo mật vì tất cả đều xử lý onchain, k có transaction nào cần dựa trên việc tính toán off-chain tiềm năng rủi ro như 1 số layer2 và mọi sự tương tác giữa các entities có thể xảy ra trong 1 atomic(nguyên tử), consistent(rắn chắc), isolated(độc lập) and durable(bền vững) (ACID) transaction.

Ngôn ngữ lập trình mới Cadence để lập trình smart contract trên Flow thích hợp với người mới, có sẵn khả năng upgrade, tiết kiệm tài nguyên, chuyên về NFT. 

Nhược điểm:
Ngôn ngữ Cadence chưa được kiểm chứng, chưa có nhiều dev, chưa kết nối được với nhiều blockchain khác. Hiện tại mới chỉ connect với Ethereum. Token quản trị vẫn đang ở trạng thái tập trung do đội ngũ phát triển vận hành. Nguồn cung coin vô hạn

Để tăng tính phi tập trung trong tương lai, họ phải chuyển nhượng các execution node cho cộng đồng. Nó sẽ tự phi tập trung dần khi số node của commmunity nhiều lên hoặc nó có thể dùng mô hình DAO để quản trị trong group của nó mọi việc thông qua voting community để tăng tính phi tập trung. Cả cái community đó là 1 tổ chức tự trị

Cadence là 1 ngôn ngữ hướng tài nguyên. Có docs và ví dụ rất cụ thể. Người dùng có thể tạo tài sản số của họ tự do có thể trade trên thị trường mở. Nó có tính chất:
Safety: cung hệ thống type system mạnh mẽ tránh bug compiletime. Tự động chặn overflow và underflow of integer, ép phải khởi tạo biến trước khi sử dụng
Security: developer state pre-conditions và post-conditions để đảm bảo code chạy đúng
Clarity, approachability and extensibility: mặc định upgradable SM. Dễ đọc và audit, review. Học ez trực tiếp trên docs

Lập trình viên trên Flow có thể tự tin xây dựng 1 DApp mà mặc định là nhanh và sẵn sàng chào đón đến hàng tỉ người dùng chứ kp lo là phí cao và chỉ có thể ít người tham gia tránh nghẽn này nọ

-> Trải nghiệm người dùng của Flow tốt vì nó tập trung vào người dùng cuối, người dùng vào trang web như 1 trang thương mai điện tử bình thường chứ kp 1 trang web blockchain phức tạp.
VD: 1 thao tác đơn giản là mua mũ cho CryptoKitty trong game dùng USDT với cơ chế sharding sẽ mất 12 giao dịch và 7 block trong khi với Flow thì chỉ mất 1 block nguyên tử
VD: Năng lượng tạo ra 1 NFT trên Flow tương đương với năng lượng dùng 1 lần search Google

Flow là blockchain nền tảng chuyên biệt về NFT
Flow dùng bộ nhớ cloud ngoài chuỗi của Filecoin phi tập trung 

-> Các mạng lưới nhanh rẻ thường bị tấn công DDoS vì phí rẻ nên có thể bỏ ra 1 khoản tiền lớn để tạo ra 1 khối lượng giao dịch cực kỳ lớn và là giao dịch thực. Như Solona bị tấn công. Kiểu này chắc phải có cơ chế timeout, xác thực, lọc IP address, collection node phải dùng các cơ chế đặc biệt để check giao dịch đầu tiên đi qua chứ.

Flow cũng có thể dùng thuật toán sao cho collection node chỉ chấp nhận 1 lượng giao dịch mà execution node có thể xử lý. Nếu DDoS xảy ra thì chỉ làm tắc collection node.
=> Bài toán tấn công DDoS kiểu này mà lại là giao dịch có nghĩa k thể ngăn chặn thì nó giống như là vấn đề về chịu tải của blockchain chứ k còn là malicious attack nx. 

-> Ta có thể hiểu sai là collection node càng nhiều thì công việc càng chia ra cho các node, thực ra có thể là tất cả làm công việc như nhau và share cho nhau để check cơ chế đồng thuận. Nhưng nếu thế thì tất cả các node phải rời nhau chứ k thể collection thì rời còn verification thì k rời, vì nếu verification mà rời thì làm sao đảm bảo đồng thuận toàn bộ mạng nên khả năng cao là ta hiểu sai => Khả năng là tất cả các node type như nhau sẽ làm 1 công việc và phải đồng thuận với nhau => ok

Bộ ba bất khả thi của blockchain: khả năng mở rộng, decentralize, bảo mật. VD blockchain bitcoin có bảo mật và decentralize nhưng khả năng mở rộng(tốc độ, phí,..) kém
Flow thì có bảo mật vì có PoS và node verification. Flow hi sinh tính decentralize hiện tại vì chưa có traffic nên các node execution vẫn là team dev. Flow có khả năng mở rộng tốt vì tốc độ nhanh và phí rẻ. Nó gần như có thể giải quyết bộ ba bất khả thi nếu sau này nó decentralize hoàn toàn các node và vẫn có cơ chế chống DDoS, xử lý giao dịch lớn thì ok => thực ra là ta thấy nó ok rồi ấy chứ vì tốc độ và phí ngang layer 2 trong khi chưa dùng đến layer 2. Dùng các nghiệp vụ thông thường ngăn chặn DDoS là ok
Flow cũng dùng 1 biến thể của HotStuff - 1 concensus mechanism. Nói là dùng PoS nhưng áp dụng biến thể này sẽ k cần validator.

Trong các ứng dụng như Google Search hay gì thì nó xử lý DDoS kiểu: load balancer chia ra làm rất nhiều server trên thế giới cũng như kiểm duyệt các địa chỉ IP gửi nhiều request.
Do đó ta k nói đến DDoS trong blockchain vì nó có các biện pháp ngăn chặn thông thường. Quan trọng là khả năng mở rộng khi đạt đến 1 tỷ người dùng thì số transaction rất nhiều
Ethereum mở rộng bằng layer2, Near mở rộng bằng sharding, Flow nhanh như khi các blokchain kia dùng giải pháp mở rộng rồi. Còn nếu sau này vượt đến chục tỷ giao dịch 1s mà kp là DDoS thì chưa rõ

API của Flow chỉ cho truy cập tối đa 2000 request 1s. Nếu nhiều hơn thì các hệ thống thông thường có thể xử lý là lưu lại vào cache, queue or từ chối

Nếu Flow lưu data trên Filecoin phi tập trung nhưng nếu sau này filecoin tăng chi phí lưu trữ sẽ ảnh hưởng tới fee của Flow. Vd Nó lưu âm thanh, hình ảnh của NFT chẳng hạn.

-> Đương nhiên đồng FLOW dùng cho những người tham gia vào node và họ cho mint vô tận để đáp ứng nhu cầu hàng tỉ người dùng trong tương lai. 
Token cũng có nhiều dạng. Ta có thể mint 1 phát như ô bitcoin cho 21 triệu coin thì sau này dù 1 tỷ người dùng thì mỗi người vẫn có thể có 1 satoshi. Ta có thể mint như ô Shiba, dù nguồn cung vô hạn nhưng ngay từ đầu có thể mint ra hàng tỷ token để giá của nó kiểu 0.0003 chẳng hạn, sau này cần thì mint hay burn tùy nhu cầu. Nhưng ô Flow lại mint ra 1 tí vô hạn từ từ thì rất nguy hiểm. Chắc chắn sẽ lạm phát và đồng thời đó là NN giá flow ngay từ đầu đã vài đô chứ kp 0.0001 đô từ đầu như các đồng khác. Mà vc mint hay k lại tùy thuộc vào dev thì có thể họ mint hàng đống cho họ r scam được. Cần kiểm soát lượng mint ra ít hay nhiều tùy thuộc vào transaction fee mà giảm cơ chế lạm phát

VD: 1 giao dịch trung bình trên Ethereum là tầm $20, còn flow là 0.001FLOW tức 0.006$ ở thời điểm hiện tại.

-> Hiện tại Flow sử dụng ít hơn 1/3 số concensus node trên mạng (chức năng mở rộng mạng lưới) và những service account quản trị key protocol factors được kiểm soát bởi đa chữ ký nên k có 1 cá nhân nào nắm giữ majority of signing => hình như đây là cơ chế vote. Mỗi lần vote là smart contract update và thực hiện theo, k chắc lắm

Lạm phát tùy vào transaction fee, càng nhiều trans sẽ càng ít lạm phát vì nhu cầu tăng. Với 1 lượng transaction volume đủ lớn, lạm phát sẽ giảm hẳn về 0 và nếu phí giao dịch vượt quá annualized staking rewared thì sẽ tạo ra phần fee thừa vì lượng reward k thể quá lớn. Phần fee thừa được đưa vào treasury để xử lý lạm phát trong tương lai => cách hay để chống lạm phát là lưu lượng lãi quá mức vào treasury.

Flow trả cho phí giao dịch cũng như data storage và sắp tới sẽ là quản trị dự án
Về Data Storage, Flow yêu cầu tất cả ví thao tác phải có 1 lượng minimum balance of Flow mà k thể spent, khoảng 1 cent thôi
=> User cần 1 lượng minimum flow cho wallet thì developer cũng cần 1 lượng minimum flow balance cho DApp của họ. Dev phải lock 1 flow để có 100MB on-chain space. Trong tương lại họ sẽ cho phép user delete wallet và Dapp data để lấy lại lượng flow lock up mà gọi là 'recycling'
=> Đó là quá trình trước đó, bh Flow đã hợp tác thêm với Filecoin. Cái flow recycling giống kiểu gas refund của Ethereum

Flow tối ưu hóa decentralization và bảo mật của Consensus Nodes vì nó yếu trước Byzantine attacks và nó limit scalability nhưng trong phạm vi chấp nhận được vì những node này có khối lượng tính toán nhỏ. Còn execution node mở rộng tốt nhưng do phần cứng bị hạn chế nên nó k được decentralized cho lắm. Nhưng nó kp vấn đề vì dishonest execution node sẽ bị detect và punish by verification node, which is decentralized and secure



# Synthetix
Phái sinh: Hợp đồng mà giá trị phụ thuộc vào tài sản cơ sở. Vd hợp đồng xác nhận quyền và nghĩa vụ các bên trong việc thanh toán tiền và chuyển giao tài sản cơ sở vào thời điểm xác định trong tương lai với mức giá thỏa thuận trước.
Underlying assets(tài sản cơ bản): vàng, nhà, xe, cổ phiếu, tiền tệ,..
Synthetix cung cấp phát hành và giao dịch 19 synth(sAsset) khác nhau đại diện cho tiền điện tử, stablecion, hàng hóa cũng như 11 Synths inverse khác nhau (iAsset) đại diện cho tiền điện tử

Synthetic có từ rất lâu đời. VD: game FIFA nó có các nhân vật như Neymar, Messi,.. và các nhân vật đó hiếm và có giá đắt hơn các nhân vật bình thường. Điều này là vì game này đã mô phỏng giá trị các nhân vật cũng như các skill của họ ngoài đời thực vào trong game 1 cách vô cùng thực tế để đánh giá nhân vật. Khi đó những nhân vật trong game mới có giá trị để mua bán đắt đỏ mà ta có thể gọi nó là Synthetic Neymar or Synthetic Messi. Vc mô phỏng giá trị ngoài đời thực vào ảo như v có thể gọi là synthetic assets nhưng hiển nhiên phải được back đầy đủ. Nếu sau này Neymar chơi kém đi thì game có thể update giảm chỉ số nhân vật
Synthetic về sau có thể hỗ trợ cả các stock như Apple, Amazon

Vd ta sở hữu giá trị của sAPPLE xong đổi ra sGOLD thông qua Synthetix.Exchange tức là ta chuyển đổi giá trị từ fame của hãng Apple thành giá trị của vàng ez thậm chí trong thực tế để mua cổ phiếu Apple và bán đi lấy vàng còn khó hơn là trong Synthetix
Tại sao người ta lại dùng synthetic mà k mua mẹ tài sản thật ? Bởi vì khi sở hữu synthetic, họ dễ trade hơn và có thể nhìn giá 1 cách trực tiếp sản phẩm đó mà không cần nguồn centralized nào làm điều đó. Thêm vào đó các tính năng của Synthetix như exchange with 0 slippage cũng tiện cho trader, họ kp vào hàng đống exchange khác nhau để trade ra cái mình muôn

Ngoại hối(foreign exchange) là từ chỉ các phương tiện sử dụng trong giao dịch quốc tế. 

Derivatives: tài sản phái sinh của tài sản cơ bản bên trên. Đây là các hợp đồng giữa các bên mà giá trị dựa trên tài sản cơ bản. Nó có thể là hợp đồng tương lai, hợp đồng tùy chọn, hợp đồng trao đổi. VD ta sở hữu tài sản phái sinh là 1 Option contract của vàng là ta được quyền mua 1gam vàng với mức giá 1 triệu trong 30 ngày tới thì dù 30 ngày tới giá vàng lên xuống như nào, ta vẫn có thể mua được với mức giá đó
Synthetic assets là sự kết hợp của nhiều loại phái sinh khác nhau VD là sự kết hợp của 1 hợp đồng quyền chọn mua và 1 hợp đồng quyền chọn bán. Nó là sự kết hợp của nhiều sản phẩm phái sinh như future contract, forward contract,... để mô phỏng giá của 1 tài sản cơ bản như hàng hóa, cổ phiếu, chỉ số chứng khoán,.. rồi trade trên đó. Synthetic assets sinh ra nhằm mô phỏng, bắt chươc giá của 1 tài sản căn bản or 1 khoản đầu tư. 
Vai trò: đa dạng hóa đầu tư thay vì chỉ tập trung vào 1 tài sản; giảm rủi ro khi mà người mua không cần mua đứt tài sản đó mà vẫn có thể kiếm lời dựa trên sự biến đổi giá của tài sản đó; lợi nhuận cao hơn; mở rộng khả năng tiếp cận của 1 loại ts với nhà đầu tư
=> Đó là synthetic assets trong tài chính truyền thống

Trong crypto cx có synthetic assets để bắt chước giá trị của tài sản khác, phát triển thêm 1 mặt của cefi vào thị trường crypto => nhà đầu tư có thể dùng crypto assets để tiếp xúc với nhiều loại tài sản mà không cần thiết phải nắm giữ chúng. VD synthetic assets như DAI của MakerDAO hay sUSD của Synthetic,.. là thứ mô phỏng USD. Crypto synthetic assets dễ dàng trao đổi hơn và không phân quyền với pool toàn cầu. 
Dự án Synthetix cung giao thức cho phép phát hành và giao dịch các synthetic assets trên ethereum. Người dùng có thể tiếp xúc với các loại tài sản như tiền fiat, hàng hóa, cổ phiếu,.. thông qua việc thế chấp token gốc của nền tảng là SNX. 
Trong hệ sinh thái Synthetic có: synthetic exchange giúp trao đổi synthetic assets và đồng SNX trực tiếp; Mint của Synthetic là 1 DApp nơi chủ sở hữu SNX phát hành synthetic assets; Dashboard cung cấp cho người dùng tổng quan về ecosystem của synthetix. VD ta có 1 lượng SNX trị giá 7500 đô ta đem lên synthetix thế chấp và nhận về 1000 sUSD thì 1000 sUSD chính là synth mô phỏng cho tài sản USD tiền ngoài đời thực. Sau đó ta có thể đem số sUSD này trade trên nền tảng DEX của synthetic. Ta cũng có thể đốt sUSD để nhận lại SNX ban đầu. 

VD: Mai và Tuấn là 2 người duy nhất ở hoạt động trên synthetic. Mỗi người có 750 đô SNX. Mai thế chấp 750$ SNX để nhận được 10$ synthetic assets của vàng. Giả sử 1 Gold = 10$ thì Mai nhận được 1 Gold. Chú ý trên synthetix tài sản quy đổi có tỉ lệ rất cao 750% thì 750$ chỉ đổi được có mỗi 10$ mà thôi. Tuấn thì 750$SNX đổi sang 10$ bạc và nhận 2 Silver(tức 1 Silver=5$). Khi 2 người tham gia vào hệ thống tức là đã vay tiền của synthetix, họ sẽ tham gia vào 1 total Global debt tổng là 20$. Về sau giá bạc tăng lên 1 Silver = 10$. tức Tuấn có 2Silver = 20$ thì pool nợ toàn cầu thành 30$ mà Tuấn và Mai ban đầu cùng nợ 10$ tức 10$ thì bh Mai vẫn nợ 50% tức 15$ và Tuấn cx 15$. Có thể thấy Tuấn có 20$ mà nợ 15$ thì lãi 5$ trong khi Mai lỗ 5$. 
Điều đặc biệt là Mai không hề động gì đến Silver nhưng silver tăng thì Mai vẫn lỗ. Trong thực tế có nhiều người tham gia vào pool chứ k chỉ có 2 người như v. Qtr là khi kiếm tiền kiểu này của synthetic thì phải thế chấp để nhận lại tài sản mà giá nó phải tăng mới có lãi. Khi có synth thì người ta thg dùng synth assets đó để trade tiếp các thứ khác trên Synthetix cơ, vd đổi vàng lấy bạc.
Trong Synthetix, ta vào 1 pool có nhiều đồng và stake SNX để mint 1 đồng trong pool. Nếu giá đồng đó tăng thì ta lãi, giá các đồng khác giảm thì ta cũng lãi. Giá đồng đó giảm or giá các đồng khác tăng thì ta lỗ
Các dự án Synthetic assets: Synthetix, UMA, Market Protocol,..
Synthetix còn kết hợp với dHedge(nền tảng quản lý tài sản phi tập trung trên Ethereum). Còn có Kwenta(nền tảng phái sinh), Lyra và Thale(thị trường options)
Kwenta dùng P2C của synthetix, slippage = 0, phí gas giảm đến 50 lần vì dùng trên layer 2 Optimism của Ethereum

Người dùng có thể chuyển đổi giữa các synth trên DEX của synthetic. Dùng SNX thế chấp phát hành synth ra thị trường. Muốn lấy lại số SNX thế chấp vào phải burn số Synth theo tỉ lệ ban đầu. Khi người dùng giao dịch các synth với nhau qua DEX thì sẽ nhận được phí thưởng.
Ưu điểm là nguồn vốn được tối ưu hóa thông qua phát hành synth chứ nó k bị khóa trong contract tạo synth 1 cách vô dụng.
Nó y hệt cơ chế lending borrowing bình thường là thế chấp để nhận synth, synth là tài sản nợ. VD: Người dùng stake SNX trong staking pool -> dùng SNX làm ts thế chấp để mint ra sUSD với tỉ lệ 500%, từ sUSD ta có thể đổi sang các synth assets khác như sBTC, sETH. Mỗi khi có giao dịch thì 1 phần phí thu về Synthetix. Người staking SNX còn được hưởng SNX token từ ngân quỹ Synthetix assets. 
Cơ chế nợ chỉ áp dụng cho những SNX staker mint ra synth còn trader giao dịch sUSD, sBTC bình thường k chịu rủi ro thanh lý

Vc Synthetix trả thưởng cho vc stake SNX là để bootstrap network thu hút người vào (giống liquitidy mining). Dù điều này lạm phát giá SNX nhưng nên nhớ nó cho stake tỉ lệ rất cao là 500%, tức là tạo ra sUSD cần 1 lượng rất lớn SNX. Chính vì cần nhiều như v nên nhu cầu mua SNX cao. Khi hệ thống càng phát triển thì càng nhiều synth được tạo ra. Càng nhiều giao dịch thì phí SNX cho staker càng nhiều. Lượng fee SNX trong Synthetix exchange là do exchange sinh ra trả cho người cung chứ người trader k cần phải sơ hữu SNX cũng đc
SNX staker chính là người tạo ra thanh khoản và đảm bảo thanh khoản cho các Synth. Giá trị toàn bộ synth trên thị trường đảm bảo được backed bởi SNX token được staking. Các SNX staker có thể phải chịu khoản lỗ vì v xứng đáng nhận phần phí giao dịch tương đương với LP token trong các AMM bth.

Còn có các pool stable coin swap ts synth (như 1 token bth). Chẳng hạn sETH/ETH thì SNX mỗi tuần sẽ cung 1 lượng làm thưởng cho những người cung thanh khoản synth trên các stable pool trên Uniswap, Curve. Điều này khuyến khích các nhà cung cấp thanh khoản cho các ts synth.

Giao dịch trên Synthetix Exchange k chịu slippage vì các synth được giao dịch theo cơ chế burn and mint theo giá mà oracle cung cấp. 
Phí gas cao vì dùng cơ chế mint and burn thay vì swap thông thường. VD người dùng gửi ts synth của mình đến 1 burn address vd gửi 45000sUSD thì lượng đó đốt và mint ra lượng sBTC tương ứng với giá cung cấp bởi oracle, lượng sBTc này sẽ chuyển đến ví người dùng luôn. 
Tương lai chuyển sang Layer 2 Optimism để có 1 dạng AMM slippage =0 và phí gas ~0 thì quá đẳng cấp. Đó là 2 vấn đề mà các AMM gặp phải
P2C(peer to contract). Giá trao đổi tài sản thông qua price feeds cung bởi oracle và converted dùng Synthetix.Exchange DApp.

Mintr là DApp tương tác với Synthetix contract, người dùng có thể stake SNX qua app này và nó sẽ mint ra synthetic assets. Người dùng phải back cho Synth bằng SNX với tỉ lệ 750%. C-ratio là 750% đảm bảo Synth được back bởi đủ lượng tài sản. Giá của SNX cũng ảnh hưởng đến đến tỉ lệ hiện tại. Người dùng phải chỉnh ratio ở mức tối ưu C-ratio bằng cách mint tiếp Synth or burn Synth. Nếu nhỏ hơn 750%, họ k thể nhận thưởng phí giao dịch.
Back là để chứng thực số tài sản đó tồn tại thực tế chứ kp ai cũng tạo bừa được. VD ta có 100 đô và ta sẵn sàng trao đổi nó lấy 1 cuốn sách do ta xuất bản chẳng hạn thì ta có thể nói cuốn sách đó giá 100$ và ai bán là ta mua nó. Cuốn sách thực tế k có giá trị nhưng ta làm cho nó có giá trị bằng cách back nó với 100$. Thực tế sUSD, sETH được back bởi 750% SNX lock trong SM nên mới có giá trị trao đổi
Để khuyến khích người dùng cung synth outside, synthetix trả thưởng cho người dùng hàng tuần. Reward cụ thể như nào được thể hiện trên Mintr DApp. Nó liệt kê các pool có thưởng SNX VD sBTC trên Curvepool hay Uniswap mà ta supply vào pool đó sẽ nhận SNX free. 

Synthetix hỗ trợ thế chấp Ether, trader có thể borrow Synth bằng ETH và trade ngay lập tức với tỉ lệ 150%. Nếu họ mint ra sETH chính nó luôn thì họ k cần phải tham gia vào pool nợ toàn cầu nhưng cx k nhận được phí và thưởng theo tg. Mỗi khi có trade thì sinh ra exchange fee gửi vào fee pool, SNX staker sẽ claim phần thưởng theo tỉ lệ hàng tuần. Họ cx nhận staking reward thông qua cơ chế lạm phát.
Người dùng stake SNX và nhận về sUSD chẳng hạn, giá của sUSD được xác định bởi tài sản cơ sở USD và Synthetix lấy nó thông qua Oracle. Khoản tiền mà người dùng tách rời với khoản nợ. Khoản tiền mà người dùng sở hữu là sUSD được biến động phụ thuộc vào USD. Còn khoản tiền mà người dùng nợ là phần trăm tổng tiền trong pool quy về 1 mệnh giá. Tùy vào pool có tổng tiền tăng hay giảm mà nợ nhiều lên hay ít lên.

Để tài sản tổng hợp luôn đúng giá với tài sản nó track, có Synth Pegging Mechanism 3 cách:
Arbitrage: SNX staker burn/mint sUSD
sETH: mỗi tuần, 1 phần SNX thêm vào tổng cung thưởng cho người tạo sETH/ETH trên Uniswap, nhờ v có các pool thanh khoản rất lớn và người dùng có thể mua bán trao đổi Synth
SNX auction: giống dFusion trên Gnosis, đấu giá SNX giá rẻ, sau đó có thể mua Synth dưới mức peg

Open market VD cặp sUSD/ETH trên pancake swap. Khi chênh giá thì mn sẽ arbitrary tiền trên các decentralized market đó để duy trì giá. 
Đáng lẽ trao đổi synth này cho synth khác thì dùng synthetix.exchange là ok nhưng do các sUSD nó cũng là ERC20 và synthetix muốn người dùng stake cũng như làm mọi thứ kbh bị vô dụng nên nhiều người tùy ý tạo các pool thanh khoản synth với các đồng khác trên thị trường được. VD sETH/ETH với tỉ giá 1 sETH= 1 ETH thoải mái

Có 5 types Synths: fiat currency là sEUR, sUSD; commodities là gold, silver; cryptocurrencies là sETH, sBTC; inverse cryptocurrencies là giá của iBTC luôn theo giá của BTC thực tế; cryptocurrencies index là sDEFI và sCEX(and inverse của nó) track theo các defi assets và centralized token
Inverse Synths(chỉ số đảo ngược). VD khi giá BTC giảm thì iBTC tăng

Ta tính debt pool bằng cách cộng số lượng token tổng trong Synth contract và nhân với exchange rate của nó(chắc kiểu giá tiền ấy) -> debt pool này có giá bằng số lượng token*giá 1 token ez
Oracle thì nó dùng thuật toán duyệt nhiều nguồn, hiện tại thì lấy từ node operator độc lập của chainlink
Ban đầu, Synthetic chưa decentralized hoàn toàn. VD: ta trade 1000 sUSD lấy 5.99 sETH thì cái giá này nó lấy từ Oracle và cái oracle này cung giá 1 cách centralized và quản lý bởi synthetic team. Hiện giờ nó đã integrate với chain link để decentralized hoàn toàn

System Architecture:
Minting Synths: SNX holder lock SNX và mint sUSD -> Synthetix contract check lượng SNX muốn mint thỏa mãn tỉ lệ nhỏ hơn 750% -> Debt sẽ add vào Debt Register là lương sUSD -> nợ được gán cho staker, synthetix contract hướng sUSD contract phát hành thêm lượng mới vào total supply và user's wallet -> Nếu giá SNX tăng thì lượng bằng giá trị cũ sẽ lock như cũ, phần còn lại unlocked và user tùy ý quyết định mint thêm sUSD hay k
SNX cũng stake để dành quyền vote quyền quản trị

Trao đổi sUSD cho sBTC, đốt sUSD, 0.3% lượng đốt vào fee pool(SNX staker nhận về sau). 99.7% còn lại thì sBTC sẽ mint ra lượng tương ứng 
Khoản nợ tổng k đổi vì same value burn và mint. 
Khi có staker nhận fee: check fee có không và staker eligible k -> lượng fee tính bằng sUSD gửi từ fee pool cho staker's wallet. Fee phân chia dựa vào tỉ lệ debt mỗi staker phát hành. 
Mỗi lần SNX holder mint or burn thì đều check debt pool cũng như nợ của mỗi staker bằng cách update Cumulative Debt Delta Ratio trên Debt Register. Mỗi khi có ai tham gia hay rời khỏi Synthetix đều ảnh hưởng đến debt của người khác. Nó k cần tính liên tục mọi lúc mà chỉ cần update thông số này cần thiết để tính debt của những người còn lại khi cần. 
Khi giao dịch, 0.3% fee được đưa vào fee pool để gửi cho SNX staker hàng tuần tương ứng khoảng thời gian mà tỉ lệ thế chấp của họ luôn >=750%. Fee này k hề được exchange mint thêm nhé nên tổng synth luôn k tự đổi nhé.

Thông tin về lần gần nhất mint và burn lưu trong Debt Register với issuance data + index number mà action diễn ra. Chi tiết nó lưu phần trăm khoản nợ so với debt pool:
User debt percentage = (new debt + existing debt)/(previous debt pool + new debt)
Cumulative Debt Delta Ratio là tích của nó với relative time(index) mà phần debt mới được add => dùng để tính bất cứ user tại bất cứ index nào trong tương lai. 
Khi burn: user's new debt percentage = (existing debt - debt to be burned)/(debt pool - debt to be burned)
Update Cumulative Debt Delta update là = debt to be burned/(debt pool - debt to be burned)
Còn khi mint: = New Debt Minted/( Total Existing Debt + New Debt)

1 risk hiện tại là debt dao động due to exchange rate shift ngay bên trong system khiến user thg bỏ nhiều hơn synth hơn lượng họ mint ban đầu. 
contract cũng dùng nhiều proxy contract để update dễ hơn sau này nhưng như v thì centralized và phải tin tưởng vào dev của synthetix
Họ dùng SIP's(Synthetix Improvement Proposals) cho phép cộng đồng đề xuất các ý tưởng change cho system.

Thanh khoản vô hạn của Synthetix là vì ta có thể đổi bất cứ 1 synth nào lấy 1 synth khác bằng Synthetix.Exchange, nó tự làm hết điều đó cho ta mà k cần người nào cung cấp thanh khoản với cơ chế nó tự burn và mint mới cho ta(thế mới gọi là P2C). Do đó ta có thể đổi bao nhiêu tùy ý vì k thể quá max lượng synth tồn tại trong hệ thống được, VD ta sở hữu tất cả synth và đổi hết sang sUSD thì Exchange sẽ sinh hết sUSD = tổng lượng synth có trong toàn bộ hệ thống là xong. Do đó ta có thể đổi từ synth này sang synth khác ngay tức khắc bất cứ lúc nào mà kp chờ khớp lệnh như mô hình order book nên giảm được slippage ~0, giá cả để đổi nó lấy từ oracle. Nó kp là trao đổi người với người mà contract mint hay burn
Synthetix.Exchange chính là Synthetix Protocol kết hợp với Kwenta

Slippage xảy ra khi thị trường biến động mạnh, trader sẽ bán tháo gây trượt giá cao. VD: Khi thị trường đang dump, bạn không thể bán BTC đúng giá $60,000 vì chắc chắn lệnh này sẽ không khớp. Bạn sẽ phải đặt lên thấp hơn là $59,990 hay $59,980. Ở trường hợp này, độ trượt giá là $10 - $20 cho giao dịch 1 BTC. Cx có thể do khối lượng giao dịch cao VD ta mua vài trăm ngìn USDT trong khi tường buy và Sell chỉ vài nghìn USDT. Or thanh khoản thấp
Slippage (%) = ( |Giá cuối cùng – Giá ban đầu| / Giá cuối cùng) x 100%
Để giảm slippage có thể lựa chọn pool thanh khoản cao, hạn chế giao dịch khi có tin tức quan trọng, tăng phí gas cao hơn

Nó hỗ trợ long và short với tài sản tổng hợp bằng sTOKEN và iTOKEN. VD khi thế chấp short thì bán đến khi giảm thì mua vào trả lại người cho vay thì ăn khoản lãi. Thì ở đây ta dùng iGOLD. Do ta k có gold nên phải mua iGOLD, khi vàng giảm thì cái iGOLD sẽ tăng bán ăn lãi.
VD: ta sở hữu sBTC và có các đặc tính của BTC dù bản thân ta k sở hữu BTC thực tế thì khi giá BTC x2 thì sBTC cũng x2. Vc hold sBTC là ta đang long.



# The Graph
The Graph index data trên block giúp query data trên blockchain tốc độ cao. Nhiều nền tảng dùng TheGraph như Uniswap, AAVE, Balancer, Decentraland.
Cơ chế: Nó đánh index data để query tốc độ cao bằng cách bắt mọi event phát bởi SM và tổng hợp lại thành 1 subgraph. Indexing node sẽ được chọn để đánh index cho data. Sau đó data có thể được queried bởi DApp khác bằng GraphQL rất dễ.

Nếu chỉ là lấy data trên blockchain thì ta hoàn toàn có thể dùng hàm getter. Nhưng VD 1 sàn giao dịch muốn hiển thị lịch sử giao dịch của người dùng sẽ phải bắt mọi event và check event nào là của người đó, VD ứng dụng tồn tại 10 năm thì ta phải bắt event trong quá khứ 10 năm liền sẽ rất lâu thậm chí là vài ngày, chưa kể phải xử lý kết hợp nhiều event lại mới tạo data hoàn chỉnh. Giải pháp là ta có thể bắt thủ công r lưu vào database, rồi tiếp tục bắt event từ thời điểm hiện tại trở đi, nhưng như v thì data show ra sẽ centralized. The Graph giúp làm điều đó dễ dàng hơn mà đảm bảo data là decentralized.

Các node của TheGraph phải stake đồng GRT vào mới thực hiện được vai trò của mình. Họ sẽ được thưởng khi người khác trả GRT để dùng data.
Có 4 đối tượng: consumer, indexer, curator, and delegator.
- Consumers là người dùng cuối trả phí cho Indexers khi dùng subgraph của họ để query data blockchain tốc độ tức thì, cường độ cao. 1 ứng dụng như Uniswap có thể có nhiều Indexer tạo subgraph và consumer tùy chọn subgraph nào giá rẻ hay có data mình cần để dùng.
- Indexers là người đánh index tạo subgraph. Họ có thể đánh index cho Uniswap hay AAVE hay bất cứ 1 nền tảng nào. Đơn giản là họ tổng hợp events rồi lưu vào DB và cung ra 1 URL. Để trở thành indexer, người dùng phải chạy GraphNode trên máy và duy trì database luôn bật cho customer lấy, phải stake GRT, phải có máy cấu hình đủ lớn. 
Họ sẽ nhận reward từ consumer trả khi sử dụng, họ được tùy ý set price cạnh tranh với các indexers khác. Họ sẽ được hoàn trả 1 phần tiền đã stake sau 1 khoảng thời gian. 
Subgraph chứa thông tin data source, block nào cần đánh index, event nào cần bắt, data được lấy dạng nào. Indexing node phải tuân theo các quy tắc đó khi đánh index cho subgraph. 
- Curator: vì có quá nhiều ứng dụng, indexer kb nên đánh index cho nền tảng nào có người sử dụng thì curator sẽ môi giới, curator thông báo indexers về subgraph nào nên tạo. Vd khi curator tìm được 1 nền tảng nên đánh index, họ deposit GRT vào "bonding curve reserve" của subgraph và nhận lại "curation shares", nếu càng nhiều curator deposit vào 1 subgraph tức nhiều người tin là nó có ích thì họ càng nhận nhiều curation shares. 
Curator có thể là người tạo ra 1 nền tảng và muốn indexer đánh index cho data của họ (họ k muốn tự làm vì k muốn cài GraphNode và thỏa mãn các điều kiện phần cứng khác). 
Curator có thể là trader tùy ý deposit hoặc remove GRT từ subgraph. Vd họ đoán 1 subgraph sẽ có nhiều người dùng thì deposit vào, thấy giá trị giảm thì rút ra. Phí nhận được là từ người dùng chia cho indexer, 1 phần được trích ra cho curator.
- Delegator hỗ trợ Indexer trong việc staking GRT vào pool. Nếu indexer kiểu muốn đánh index nhưng k có GRT để stake, delegator sẽ stake vào pool thay cho indexer đó và ăn 1 phần phí từ query của consumer, hoặc họ có thể stake thêm vào cho indexer để tăng độ uy tín của subgraph(càng nhiều đồng stake thì subgraph càng uy tín và càng nhiều người chọn vì nếu indexer gian lận sẽ mất hết tiền đã staked). Delegator phải chọn indexer cẩn thận để ăn phí và hoàn vốn.

Khi có vấn đề, 2 role mới xuất hiện:
- Fisherman: chạy 1 loại node có nhiệm vụ tìm data sai lệch cung bởi indexer và report tới Arbitrators.
- Arbitrators: Khi indexers bị report sẽ bị phạt. Arbitrators có quyền giảm GRT stake của defective Indexer bị report, thậm chí xóa họ khỏi network nếu tình huống nghiêm trọng.

=> ref tới "Tương tác The Graph"
-> Tương tác với graph như http bth

-> Tạo 1 subgraph
Phần lớn code là tự gen. Ta cần tạo Schema cho các data cần lấy, viết yaml cho config rồi viết file mapping handler return data cụ thể
Phải setting cài đặt các tool

URL: https://thegraph.com/docs/vi/developing/creating-a-subgraph/

